#' GTFS Lengther
#'
#' This function adds missing time and length information about the routes using the gmapsdistance package.
#'
#' @param gtfs.obj a GTFS object, preferrably generated by the function TO DO
#' @param skip An integer describing the number of rows at the start of the gtfs object to skip.
#' @param batch.size An integer describing how many rows to work on at once. This is primarily used for two reasons: first, it may be necessary to limit the number of simultaneous (or near simultaneous) calls made to the Google Maps API; second, it can be useful for error tracking. The default value of 50 can generally be used without issue.
#' @param location A character string describing which file to save the results to. Defaults to "./GTFS Local Results/GMapsResults".  The directory must exist.
#' @param logs Logical. If `TRUE`, the system will keep and store a log for troubleshooting
#' @param quiet Logical. If `FALSE`, the system will print messages to the terminal when it starts each batch and when the last batch is complete.
#' @param ignore.local Logical. If `FALSE`, the save location will be checked to see if a local file already exists. If it does, the local file will be used instead of generating a new `gmapsresults`.
#'
#' @return A new gtfs.obj with the lengths and times included in the stop_times dataframe.
#' @export
#'
#' @examples
#' gtfs_length(gtfs.obj)
#'
gtfs_lengthr <- function(gtfs.obj, skip = 0, batch.size = 50, location = "./GTFS Local Data/GMapsResults/",
                         logs = FALSE, quiet = TRUE, ignore.local = FALSE) {

  if(!requireNamespace("gmapsdistance", quietly = TRUE)) {
    stop("You must install the package \"gmapsdistance\" and have a valid Google Maps API key to use this function." )
    call. = FALSE
  }

  agency <- gtfs.obj$agency$agency_name[1]
  stops <- gtfs.obj$stops
  trips <- gtfs.obj$trips
  stop.times <- gtfs.obj$stop_times

  #check for a local file - do we need this?
  # if(!ignore.local) {
  #   if(file.exists(file.path(location, paste(agency, "Complete.RDS")))) {
  #     if(!quiet) {
  #       message("Length file found locally. Using local file...\n")
  #     }
  #     gtfs.obj <- lengthr_local(gtfs.obj, local.file = location)
  #     return(gtfs.obj)
  #   }
  # }

  stop.times <- stop.times %>%
    inner_join(select(stops, stop_id, stop_lat, stop_lon))
  stop.times <- stop.times %>%
    mutate(destination = paste(stop_lat, stop_lon, sep="+"),
           origin = lag(paste(stop_lat, stop_lon, sep="+")),
           refid = c(1:nrow(stop.times))) %>%
    mutate(refcoords = paste(origin, destination, sep="+")) %>%
    group_by(trip_id)

  trip.starts <- stop.times %>% group_by(trip_id) %>% filter(row_number() == 1)

  dir.create(location, showWarnings = FALSE, recursive = TRUE)

  if(file.exists(file.path(location, paste(agency, " Complete.RDS", sep = "")))) {
    gmaps.results <- readRDS(file.path(location, paste(agency, " Complete.RDS", sep = "")))
  } else {
    gmaps.calls <- stop.times[-trip.starts$refid, c("destination", "origin", "refcoords")] %>% unique()

    rows <- nrow(gmaps.calls)
    start <- skip + 1
    batches <- rows %/% batch.size + 1
    if(logs) { batch.log <- data.frame(Batch = 1:batches, Check = 0, Time = NA) }

    for(i in start:batches) {
      if(!quiet) { cat("Now working on batch ", as.character(i), " of ", as.character(batches), "...\n", sep = "") }
      start.loop <- (batch.size*(i-1) + 1)
      stop.loop <- batch.size*i

      if(stop.loop > nrow(gmaps.calls)) { stop.loop <- nrow(gmaps.calls) }

      batch.loop <- gmaps.calls[start.loop:stop.loop,]
      if(nrow(batch.loop) == 1) { batch.loop <- rbind(batch.loop, batch.loop) }

      result.loop <- gmapsdistance::gmapsdistance(origin = batch.loop$origin,
                                                  destination = batch.loop$destination,
                                                  combinations = "pairwise",
                                                  mode = "driving")

      batch.loop <- cbind(result.loop$Time, result.loop$Distance$Distance, result.loop$Status$status) %>%
        mutate(refcoords = paste(or, de, sep = "+"))

      dir.create(file.path(location, "Batches"), recursive = TRUE)

      write.csv(batch.loop, file.path(location, "Batches/", paste(agency, " Batch ", i, ".csv", sep = "")), row.names = FALSE)

      if(!exists("gmaps.results")) {
        gmaps.results <- data.frame(batch.loop)
      } else {
        tmp <- data.frame(batch.loop)
        gmaps.results <- rbind(gmaps.results, tmp)
      }

      if(logs) {
        dir.create(file.path(location, "Logs"), recursive = TRUE, showWarnings = FALSE)
        saveRDS(gmaps.results, file = file.path(location, paste(Sys.Date(), agency, " Interim.RDS", sep = "")))
        batch.log[i, "Check"] <- 1
        batch.log[i, "Time"] <- Sys.time()
        write.csv(batch.log, file = file.path(location, paste("Logs/", agency, " Log.csv", sep = "")), row.names = FALSE)
      }
    }
  }
  if(!quiet) { cat("Done!\n") }
  write.csv(gmaps.results, file = file.path(location, paste(agency, " Complete.csv", sep = "")), row.names = FALSE)
  saveRDS(gmaps.results, file = file.path(location, paste(agency, " Complete.RDS", sep = "")))

  stop.times <- stop.times %>% left_join(gmaps.results) %>% select(-c(destination, origin, refid, refcoords, or, de)) %>%
    dplyr::rename(DistM = result.loop.Distance.Distance, TimeS = Time)

  gtfs.obj$stop_times <- stop.times
  rm(gmaps.results)
  return(gtfs.obj)
}

#' Lengthr Local
#'
#' Identical functionality to `gtfs_lengthr`, except using a local file instead of generating the results using `gmapsdistance`.
#'
#' @param gtfs.obj a GTFS object to be lengthed.
#' @param local.file the location of the file containing the `gmapsdistance` results. Defaults to the same as the output files of `gtfs_lengthr`.
#'
#' @return a gtfs object with a modified `stop_times_df`, equivalent to the output of `gtfs_lengthr`.
#' @export
#'
#' @examples
#' lengthr_local(gtfs.obj)
#' #works as called from gtfs_lengthr
#'
lengthr_local <- function(gtfs.obj, local.file = "./GTFS Local Data/GMapsResults") {
  file.to.read <- file.path(local.file, paste(gtfs.obj$agency_df$agency_name, "Complete.RDS"))
  if(!file.exists(file.to.read)) {
    stop("Local gtfs_lengthr output not found. Please check location or run `gtfs_lengthr()`.")
  }
  gmapsresults <- readRDS(file.to.read)
  stops <- gtfs.obj$stops
  stop.times <- gtfs.obj$stop_times
  stop.times <- stop.times %>% inner_join(select(stops, stop_id, stop_lat, stop_lon))
  stop.times <- stop.times %>%
    mutate(destination = paste(stop_lat, stop_lon, sep = "+"),
           origin = lag(paste(stop_lat, stop_lon, sep = "+")),
           refid = c(1:nrow(stop.times))) %>%
    mutate(refcoords = paste(origin, destination, sep = "+")) %>%
    group_by(trip_id)

  stop.times <- stop.times %>% left_join(gmapsresults) %>%
    select(-c(destination, origin, refid, refcoords, or, de)) %>%
    rename(DistM = result.loop.Distance.Distance, TimeS = Time)
  gtfs.obj$stop_times <- stop.times
  return(gtfs.obj)
}

#' GTFS Framer
#'
#' This function takes a GTFS Object that has been downloaded with gtfs_loader and treated with gtfs_lengthr to disentangles the trips, routes, and service IDs into a single data.frame.
#'
#' @param gtfs.obj a gtfs object that has been treated with gtfs_lengthr
#'
#' @return
#' @export
#'
#' @examples
#'
gtfs_framer <- function(gtfs.obj) {
  routes <- gtfs.obj$routes
  stops <- gtfs.obj$stops
  trips <- gtfs.obj$trips
  agency <- gtfs.obj$agency
  stop.times <- gtfs.obj$stop_times
  calendar <- gtfs.obj$calendar
  calendar.dates <- gtfs.obj$calendar_dates

  stop.times$departure_time <- as.POSIXct(sapply(stop.times$departure_time, dater, USE.NAMES = FALSE), origin = "1970-01-01")
  stop.times$arrival_time <- as.POSIXct(sapply(stop.times$arrival_time, dater, USE.NAMES = FALSE), origin = "1970-01-01")

  if(!("shape_dist_traveled" %in% names(stop.times))) { stop.times$shape_dist_traveled <- NA }

  trip.info <- select(stop.times, trip_id, arrival_time, departure_time, shape_dist_traveled, TimeS, DistM) %>%
    group_by(trip_id) %>%
    summarise(start.time = min(arrival_time,na.rm=T), end.time = max(departure_time,na.rm=T), num.stops = n(),
              dist.GTFS = max(shape_dist_traveled, na.rm=T), dist.gmaps = sum(DistM, na.rm = TRUE), time.gmaps = sum(TimeS, na.rm = TRUE)) %>%
    mutate(duration = end.time - start.time)

  route.info <- select(routes, route_short_name, route_id) %>% inner_join(select(trips, route_id, service_id, trip_id)) %>%
    inner_join(select(trip.info, trip_id, start.time, end.time, num.stops, dist.GTFS, duration, dist.gmaps, time.gmaps)) %>%
    inner_join(select(routes, route_id, route_short_name, route_long_name)) %>%
    mutate(duration = duration/60, dur.gmaps = time.gmaps/60,
           start.time = as.POSIXct(start.time, origin="1970-01-01"), end.time = as.POSIXct(end.time, origin="1970-01-01"))

  return(route.info)
}

#' Year Tabler
#'
#' This function builds a base calendar of the year for use in constructing the timetable of a transit network.
#'
#' @param gtfs.obj a gtfs object treated with gtfs_lengthr
#'
#' @return data.frame, a base calendar to use as an input toe day_tabler.
#' @export
#'
#' @examples
#'
year_tabler <- function(gtfs.obj) {
  gtfs.cal <- gtfs.obj$calendar

  cal.base <- data.frame("Days" = 1:365, "Wkdy" = rep_len(c("monday","tuesday","wednesday","thursday","friday","saturday","sunday"),365))

  services <- gtfs.cal$service_id

  gtfs.cal$start.lubridate <- lubridate::ymd(gtfs.cal$start_date)
  gtfs.cal$end.lubridate <- lubridate::ymd(gtfs.cal$end_date)

  today <- Sys.Date()
  day.one <- paste(as.character(lubridate::year(today)), "0101", sep = "")
  day.last <- paste(as.character(lubridate::year(today)), "1231", sep = "")

  gtfs.cal$start_date[gtfs.cal$start.lubridate <= min(gtfs.cal$start.lubridate) + lubridate::days(7)] <- day.one
  gtfs.cal$start_date[as.numeric(gtfs.cal$start_date) < as.numeric(day.one)] <- day.one
  gtfs.cal$end_date[gtfs.cal$end.lubridate >= max(gtfs.cal$end.lubridate)-lubridate::days(7)] <- day.last
  gtfs.cal$end_date[as.numeric(gtfs.cal$end_date) > as.numeric(day.last)] <- day.last

  for(i in 1:length(services)) {
    serv.start <- lubridate::yday(as.Date(gtfs.cal$start_date[i], format = "%Y%m%d"))
    serv.end <- lubridate::yday(as.Date(gtfs.cal$end_date[i],format = "%Y%m%d"))
    for(j in serv.start:serv.end){
      cal.base[j, paste(services[i])] <- gtfs.cal[i, paste(cal.base$Wkdy[j])]
    }
  }
  #handle exceptions as noted in calendar_dates
  if(exists("gtfs.obj$calendar_dates")) {
    exceptions <- gtfs.obj$calendar_dates

    if(!is.null(exceptions) & nrow(exceptions)>=1) {
      exceptions$yday <- lubridate::yday(as.Date(exceptions$date, format = "%Y%m%d"))
      for(i in 1:nrow(exceptions)) {
        #exception type 1 adds service where there ordinarily wouldn't be service (special events, etc)
        if(exceptions$exception_type[i] == 1) {
          cal.base[cal.base$Days == exceptions$yday[i], paste(exceptions$service_id[i])] <- 1
        }
        #exception type 2 removes service where there ordinarily would be service (holidays, etc)
        if(exception$exception_type[i] == 2) {
          cal.base[cal.base$Days == exceptions$yday[i], paste(exceptions$service_id[i])] <- 0
        }
      }
    }
  }
  return(cal.base)
}
