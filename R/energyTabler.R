#' GTFS Lengther
#'
#' This function adds missing time and length information about the routes using the gmapsdistance package.
#'
#' @param gtfs.obj a GTFS object generated by the function `tidytransit::read_gtfs()`
#' @param skip An integer describing the number of rows at the start of the gtfs object to skip.
#' @param batch.size An integer describing how many rows to work on at once. This is primarily used for two reasons: first, it may be necessary to limit the number of simultaneous (or near simultaneous) calls made to the Google Maps API; second, it can be useful for error tracking. The default value of 50 can generally be used without issue.
#' @param location A character string describing which file to save the results to. Defaults to "./GTFS Local Results/GMapsResults".  The directory must exist.
#' @param logs Logical. If `TRUE`, the system will keep and store a log for troubleshooting
#' @param quiet Logical. If `FALSE`, the system will print messages to the terminal when it starts each batch and when the last batch is complete.
#' @param ignore.local Logical. If `FALSE`, the save location will be checked to see if a local file already exists. If it does, the local file will be used instead of generating a new `gmapsresults`.
#'
#' @return A new gtfs.obj with the lengths and times included in the stop_times dataframe.
#' @export
#'
#' @examples
#' gtfs_length(gtfs.obj)
#'
gtfs_lengthr <- function(gtfs.obj, skip = 0, batch.size = 50, location = "./GTFS Local Data/GMapsResults/",
                         logs = FALSE, quiet = TRUE, ignore.local = FALSE) {

  if(!requireNamespace("gmapsdistance", quietly = TRUE)) {
    stop("You must install the package \"gmapsdistance\" and have a valid Google Maps API key to use this function." )
    call. = FALSE
  }

  agency <- gtfs.obj$agency$agency_name[1]
  stops <- gtfs.obj$stops
  trips <- gtfs.obj$trips
  stop.times <- gtfs.obj$stop_times

  #check for a local file - do we need this?
  # if(!ignore.local) {
  #   if(file.exists(file.path(location, paste(agency, "Complete.RDS")))) {
  #     if(!quiet) {
  #       message("Length file found locally. Using local file...\n")
  #     }
  #     gtfs.obj <- lengthr_local(gtfs.obj, local.file = location)
  #     return(gtfs.obj)
  #   }
  # }

  stop.times <- stop.times %>%
    inner_join(select(stops, stop_id, stop_lat, stop_lon))
  stop.times <- stop.times %>%
    mutate(destination = paste(stop_lat, stop_lon, sep="+"),
           origin = lag(paste(stop_lat, stop_lon, sep="+")),
           refid = c(1:nrow(stop.times))) %>%
    mutate(refcoords = paste(origin, destination, sep="+")) %>%
    group_by(trip_id)

  trip.starts <- stop.times %>% group_by(trip_id) %>% filter(row_number() == 1)

  dir.create(location, showWarnings = FALSE, recursive = TRUE)

  if(file.exists(file.path(location, paste(agency, " Complete.RDS", sep = "")))) {
    gmaps.results <- readRDS(file.path(location, paste(agency, " Complete.RDS", sep = "")))
  } else {
    gmaps.calls <- stop.times[-trip.starts$refid, c("destination", "origin", "refcoords")] %>% unique()

    rows <- nrow(gmaps.calls)
    start <- skip + 1
    batches <- rows %/% batch.size + 1
    if(logs) { batch.log <- data.frame(Batch = 1:batches, Check = 0, Time = NA) }

    for(i in start:batches) {
      if(!quiet) { cat("Now working on batch ", as.character(i), " of ", as.character(batches), "...\n", sep = "") }
      start.loop <- (batch.size*(i-1) + 1)
      stop.loop <- batch.size*i

      if(stop.loop > nrow(gmaps.calls)) { stop.loop <- nrow(gmaps.calls) }

      batch.loop <- gmaps.calls[start.loop:stop.loop,]
      if(nrow(batch.loop) == 1) { batch.loop <- rbind(batch.loop, batch.loop) }

      result.loop <- gmapsdistance::gmapsdistance(origin = batch.loop$origin,
                                                  destination = batch.loop$destination,
                                                  combinations = "pairwise",
                                                  mode = "driving")

      batch.loop <- cbind(result.loop$Time, result.loop$Distance$Distance, result.loop$Status$status) %>%
        mutate(refcoords = paste(or, de, sep = "+"))

      dir.create(file.path(location, "Batches"), recursive = TRUE)

      write.csv(batch.loop, file.path(location, "Batches/", paste(agency, " Batch ", i, ".csv", sep = "")), row.names = FALSE)

      if(!exists("gmaps.results")) {
        gmaps.results <- data.frame(batch.loop)
      } else {
        tmp <- data.frame(batch.loop)
        gmaps.results <- rbind(gmaps.results, tmp)
      }

      if(logs) {
        dir.create(file.path(location, "Logs"), recursive = TRUE, showWarnings = FALSE)
        saveRDS(gmaps.results, file = file.path(location, paste(Sys.Date(), agency, " Interim.RDS", sep = "")))
        batch.log[i, "Check"] <- 1
        batch.log[i, "Time"] <- Sys.time()
        write.csv(batch.log, file = file.path(location, paste("Logs/", agency, " Log.csv", sep = "")), row.names = FALSE)
      }
    }
  }
  if(!quiet) { cat("Done!\n") }
  write.csv(gmaps.results, file = file.path(location, paste(agency, " Complete.csv", sep = "")), row.names = FALSE)
  saveRDS(gmaps.results, file = file.path(location, paste(agency, " Complete.RDS", sep = "")))

  stop.times <- stop.times %>% left_join(gmaps.results) %>% select(-c(destination, origin, refid, refcoords, or, de)) %>%
    dplyr::rename(DistM = result.loop.Distance.Distance, TimeS = Time)

  gtfs.obj$stop_times <- stop.times
  rm(gmaps.results)
  return(gtfs.obj)
}

#' Lengthr Local
#'
#' Identical functionality to `gtfs_lengthr`, except using a local file instead of generating the results using `gmapsdistance`.
#'
#' @param gtfs.obj a GTFS object to be lengthed.
#' @param local.file the location of the file containing the `gmapsdistance` results. Defaults to the same as the output files of `gtfs_lengthr`.
#'
#' @return a gtfs object with a modified `stop_times_df`, equivalent to the output of `gtfs_lengthr`.
#' @export
#'
#' @examples
#' lengthr_local(gtfs.obj)
#' #works as called from gtfs_lengthr
#'
lengthr_local <- function(gtfs.obj, local.file = "./GTFS Local Data/GMapsResults") {
  file.to.read <- file.path(local.file, paste(gtfs.obj$agency_df$agency_name, "Complete.RDS"))
  if(!file.exists(file.to.read)) {
    stop("Local gtfs_lengthr output not found. Please check location or run `gtfs_lengthr()`.")
  }
  gmapsresults <- readRDS(file.to.read)
  stops <- gtfs.obj$stops
  stop.times <- gtfs.obj$stop_times
  stop.times <- stop.times %>% inner_join(select(stops, stop_id, stop_lat, stop_lon))
  stop.times <- stop.times %>%
    mutate(destination = paste(stop_lat, stop_lon, sep = "+"),
           origin = lag(paste(stop_lat, stop_lon, sep = "+")),
           refid = c(1:nrow(stop.times))) %>%
    mutate(refcoords = paste(origin, destination, sep = "+")) %>%
    group_by(trip_id)

  stop.times <- stop.times %>% left_join(gmapsresults) %>%
    select(-c(destination, origin, refid, refcoords, or, de)) %>%
    rename(DistM = result.loop.Distance.Distance, TimeS = Time)
  gtfs.obj$stop_times <- stop.times
  return(gtfs.obj)
}

#' GTFS Framer
#'
#' This function takes a GTFS Object that has been downloaded with gtfs_loader and treated with gtfs_lengthr to disentangles the trips, routes, and service IDs into a single data.frame.
#'
#' @param gtfs.obj a gtfs object that has been treated with gtfs_lengthr
#'
#' @return The pertinent information used in other functions to develop the energy table, disentangled into a single data.frame.
#' @export
#'
#' @examples
#'
gtfs_framer <- function(gtfs.obj) {
  routes <- gtfs.obj$routes
  stops <- gtfs.obj$stops
  trips <- gtfs.obj$trips
  agency <- gtfs.obj$agency
  stop.times <- gtfs.obj$stop_times
  calendar <- gtfs.obj$calendar
  calendar.dates <- gtfs.obj$calendar_dates

  stop.times$departure_time <- as.POSIXct(sapply(stop.times$departure_time, dater, USE.NAMES = FALSE), origin = "1970-01-01")
  stop.times$arrival_time <- as.POSIXct(sapply(stop.times$arrival_time, dater, USE.NAMES = FALSE), origin = "1970-01-01")

  if(!("shape_dist_traveled" %in% names(stop.times))) { stop.times$shape_dist_traveled <- NA }

  trip.info <- select(stop.times, trip_id, arrival_time, departure_time, shape_dist_traveled, TimeS, DistM) %>%
    group_by(trip_id) %>%
    summarise(start.time = min(arrival_time,na.rm=T), end.time = max(departure_time,na.rm=T), num.stops = n(),
              dist.GTFS = max(shape_dist_traveled, na.rm=T), dist.gmaps = sum(DistM, na.rm = TRUE), time.gmaps = sum(TimeS, na.rm = TRUE)) %>%
    mutate(duration = end.time - start.time)

  route.info <- select(routes, route_short_name, route_id) %>% inner_join(select(trips, route_id, service_id, trip_id)) %>%
    inner_join(select(trip.info, trip_id, start.time, end.time, num.stops, dist.GTFS, duration, dist.gmaps, time.gmaps)) %>%
    inner_join(select(routes, route_id, route_short_name, route_long_name)) %>%
    mutate(duration = duration/60, dur.gmaps = time.gmaps/60,
           start.time = as.POSIXct(start.time, origin="1970-01-01"), end.time = as.POSIXct(end.time, origin="1970-01-01"))

  return(route.info)
}

#' Year Tabler
#'
#' This function builds a base calendar of the year for use in constructing the timetable of a transit network.
#'
#' @param gtfs.obj a gtfs object treated with gtfs_lengthr
#'
#' @return data.frame, a base calendar to use as an input toe day_tabler.
#' @export
#'
#' @examples
#'
year_tabler <- function(gtfs.obj) {
  gtfs.cal <- gtfs.obj$calendar

  cal.base <- data.frame("Days" = 1:365, "Wkdy" = rep_len(c("monday","tuesday","wednesday","thursday","friday","saturday","sunday"),365))

  services <- gtfs.cal$service_id

  gtfs.cal$start.lubridate <- lubridate::ymd(gtfs.cal$start_date)
  gtfs.cal$end.lubridate <- lubridate::ymd(gtfs.cal$end_date)

  today <- Sys.Date()
  day.one <- paste(as.character(lubridate::year(today)), "0101", sep = "")
  day.last <- paste(as.character(lubridate::year(today)), "1231", sep = "")

  gtfs.cal$start_date[gtfs.cal$start.lubridate <= min(gtfs.cal$start.lubridate) + lubridate::days(7)] <- lubridate::as_date(day.one)
  gtfs.cal$start_date[as.numeric(gtfs.cal$start_date) < as.numeric(day.one)] <- lubridate::as_date(day.one)
  gtfs.cal$end_date[gtfs.cal$end.lubridate >= max(gtfs.cal$end.lubridate)-lubridate::days(7)] <- lubridate::as_date(day.last)
  gtfs.cal$end_date[as.numeric(gtfs.cal$end_date) > as.numeric(day.last)] <- lubridate::as_date(day.last)

  for(i in 1:length(services)) {
    serv.start <- lubridate::yday(as.Date(gtfs.cal$start_date[i], format = "%Y%m%d"))
    serv.end <- lubridate::yday(as.Date(gtfs.cal$end_date[i],format = "%Y%m%d"))
    for(j in serv.start:serv.end){
      cal.base[j, paste(services[i])] <- gtfs.cal[i, paste(cal.base$Wkdy[j])]
    }
  }
  #handle exceptions as noted in calendar_dates
  if(exists("gtfs.obj$calendar_dates")) {
    exceptions <- gtfs.obj$calendar_dates

    if(!is.null(exceptions) & nrow(exceptions)>=1) {
      exceptions$yday <- lubridate::yday(as.Date(exceptions$date, format = "%Y%m%d"))
      for(i in 1:nrow(exceptions)) {
        #exception type 1 adds service where there ordinarily wouldn't be service (special events, etc)
        if(exceptions$exception_type[i] == 1) {
          cal.base[cal.base$Days == exceptions$yday[i], paste(exceptions$service_id[i])] <- 1
        }
        #exception type 2 removes service where there ordinarily would be service (holidays, etc)
        if(exception$exception_type[i] == 2) {
          cal.base[cal.base$Days == exceptions$yday[i], paste(exceptions$service_id[i])] <- 0
        }
      }
    }
  }
  return(cal.base)
}

#' Day Tabler
#'
#' This function takes the calendar generated by year_tabler and the trip information generated by gtfs_framer and makes a list of all trips for each day of the year.
#'
#' @param calendar data.frame, the output from year_tabler should be used.
#' @param trips data.frame, containing trip information generated by gtfs_framer
#'
#' @return list, a list of days for which all trips are included
#' @export
#'
#' @examples
#'
day_tabler <- function(calendar = NA, trips = NA) {
  day.table <- list()

  for(i in 1:365) {
    day.services <- names(calendar)[which(calendar[calendar$Days == i, -(1:2)] == 1) + 2]
    day.table[[paste("Day_", i, sep = "")]] <- trips[trips$service_id %in% day.services,]

    day.table[[i]]$start.time <- day.table[[i]]$start.time + lubridate::days(i - 1)
    day.table[[i]]$end.time <- day.table[[i]]$end.time + lubridate::days(i - 1)


  }
  return(day.table)
}

#' GTFS Summarize
#'
#' This function takes a time table generated by day_tabler and a GTFS object treated by gtfs_lengthr and uses those to generate and save a final data.frame and RDS file to be used for energy modeling.
#'
#' @param time.table data.frame, generated by day_tabler.
#' @param gtfs.obj a gtfs object treated with gtfs_lengthr
#' @param start.day integer, the starting day for setup
#' @param end.day integer, the ending day for setup
#' @param location character string, the location for saving the RDS files. Defaults to "./Results/Pre Fuel/". If the directory doesn't exist, it will be created.
#'
#' @return
#' @export
#'
#' @examples
#'
gtfs_summarize <- function(time.table, gtfs.obj, start.day = 1, end.day = 365, location = "./Results/Pre Fuel/") {

  agency <- paste(gtfs.obj$agency$agency_name[1])
  trips <- NA
  routes <- NA
  trip.duration <- NA
  stops <- NA
  distance <- NA
  day <- NA

  for(i in start.day:end.day) {
    trips <- c(trips, nrow(time.table[[i]]))
    routes <- c(routes, dim(unique(time.table[[i]]$route_id))[1])
    trip.duration <- c(trip.duration, sum(time.table[[i]]$time.gmaps, na.rm = TRUE))
    stops <- c(stops, sum(time.table[[i]]$num.stops, na.rm = TRUE))
    distance <- c(distance, sum(time.table[[i]]$dist.gmaps, na.rm = TRUE))
    day <- c(day, i)
  }

  daily.summary.stats <- data.frame(trips, routes, trip.duration, stops, distance, day)
  daily.summary.stats$day <- 0:365
  daily.summary.stats$date <- jan_first() + lubridate::days(daily.summary.stats$day - 1)
  daily.summary.stats <- daily.summary.stats[-1,]

  summary.df <- bind_rows(time.table) %>% data.frame() %>%
    rename(durGTFSmin = duration, distGMAPSmet = dist.gmaps, timeGMAPSsec = time.gmaps, timeGMAPSmin = dur.gmaps)

  #utils::write.csv(daily.summary.stats, file = "")
  #utils::write.csv(summary.df, file = "")
  if(!dir.exists(location)) {
    dir.create(location, showWarnings = FALSE, recursive = TRUE)
  }
  saveRDS(summary.df, file = file.path(location, paste(agency, " All Annual Routes.RDS", sep = "")))

  return(summary.df)
}


#' Create Energy Table
#'
#' This function takes a GTFS object generated by gtfs_lengthr and develops and saves an energy table for each route in that network.
#'
#' @param gtfs.obj a gtfs object generated by `tidytransit::read_gtfs()`.
#' @param large.Ag a boolean. If `TRUE`, regression will be against large, urban networks.  If `FALSE`, regression will be against small, rural networks
#' @param mass.vec a vector of masses to calculate energy for. If left as `NULL` (default), values for average 35ft, 40ft, and 60ft buses will be calculated.
#' @param mass.labels a vector of characters containing the labels for the bus types.  Must match the `length()` of `mass.vec`
#' @param input.loc a character containing the location of the google maps results as an RDS file.
#' @param output.loc a character containing the location to save the energy tables.
#' @param summary.loc a character containing the location of the summary file generated by `gtfs_summer`
#' @param surpress.output a boolean. If `TRUE`, the energy table will not be returned; the function will instead return `0` to signify successful completion.  If `FALSE`, the energy table is returned.
#' @param save.output a boolean. If `TRUE`, the output will be saved in the specified `output.loc`.
#'
#' @return 0 if the table was created successfully (or already exists), or the created energy table (see `surpress.output` for more information).
#' @export
#'
#' @examples
#'
energy_tabler <- function(gtfs.obj, large.Ag, mass.vec = NULL, mass.labels = NULL, input.loc = "./GTFS Local Data/GMapsResults",
                          output.loc = "./Energy Tables", summary.loc = "./Results/Pre Fuel", ignore.Existing = FALSE, surpress.output = TRUE, save.output = TRUE) {
  ag.name <- gtfs.obj$agency$agency_name
  file.check <- file.path(input.loc, paste(ag.name, "Energy Table.csv"))
  if(!ignore.Existing & file.exists(file.check)) {
    send.message <- paste("Energy table already exists for", ag.name)
    message(send.message)
    if(surpress.output) {
      return(0)
    } else {
      return(read_csv(file.check))
    }
  }

  if(length(mass.vec) != length(mass.labels) && !(is.null(mass.vec))) {
    stop("Lengths of masses and labels do not match.")
  }

  fleetDNA <- data.table::fread("https://www.nrel.gov/transportation/assets/docs/data_for_fleet_dna_transit_buses.csv")

  #physical constants
  g <- 9.81 #m/s^2
  Cd <- 0.51 #drag coeff of bus with slight slant on windshield (Taherian, 2014)
  RRC <- 0.01 #Rolling Coeff
  FA <- 8.0 #m^2 #Frontal Area
  Airden <- 1.221 #kg/m^3 #Air density
  vAero <- fleetDNA$aerodynamic_speed #vector of aerodynamic speeds of buses (accounting for wind)
  KI <- fleetDNA$kinetic_intensity/1000 #convert ki from 1/km to 1/m
  accel <- fleetDNA$characteristic_acceleration
  decel <- fleetDNA$characteristic_deceleration
  dist <- fleetDNA$distance_total*1.60934*1000 #convert miles to meters
  time <- fleetDNA$driving_time_seconds

  #Fleet DNA is broken into 2 segments based on deployment id: large/urban and small/rural
  fleetDNA$tag <- ifelse(fleetDNA$did %in% c(17:19), "Small.Rural", "Large.Urban")

  accel.Model <- lm(characteristic_acceleration ~ 0 + factor(tag)*stops_per_mile + factor(tag)*I(stops_per_mile^2)
                    -stops_per_mile-factor(tag)-I(stops_per_mile^2), data = fleetDNA)

  speed.Model <- lm(aerodynamic_speed ~ 0 + driving_average_speed, data = fleetDNA)

  #get regression coefficients
  speed.Coef <- coefficients(speed.Model)
  accel.Coef <- coefficients(accel.Model)

  #some mapping functions
  speed.Map <- function(speed) {
    return(speed*speed.Coef[1])
  }

  accel.Map.SR <- function(stops) {
    return(accel.Coef[1]*stops - accel.Coef[3]*(stops^2))
  }

  accel.Map.LU <- function(stops) {
    return(accel.Coef[2]*stops - accel.Coef[4]*(stops^2))
  }

  #Physival properties of the system as functions
  approx.sfc <- function(c.aero, v.aero, c.roll, ai, eff.drive, eff.regen) {
    return((c.aero*v.aero^2 + c.roll + ai * (1 - eff.regen)) / eff.drive)
  }

  c.Aero <- function(mass) {
    return(((1/2)*Airden*Cd*FA)/(mass))
  }

  sfc.kWh <- function(sfc, mass) {
    return((sfc/1000)*mass)
  }

  sfc.mpg <- function(sfc,mass) {
    return(1 / (((sfc/1000)*mass)/30.21148))
  }

  #Energy calculation functions for large/urban and small/rural networks
  enCalc.SR <- function(gtfsFile, length) {
    temp <- gtfsFile
    temp$miles <- temp$distGMAPSmet*0.000621371
    temp$stops_mile <- temp$num.stops/temp$miles
    temp$avg_speed <- temp$miles/(temp$timeGMAPSmin/60)
    temp$ai <- with(temp, accel.Map.SR(stops_mile))
    temp$vaero <- with(temp, speed.Map(avg_speed))
    temp$mass <- masses[length]
    temp$bus_type <- bus.labels[length]
    for(j in 1:length(drive.Eff)) {
      temp[, names[j] ] <- with(temp, approx.sfc(c.Aero(mass), vAero, c.Roll, ai, drive.Eff[j], regen.Eff[j]))
      temp[, names2[j] ] <- with(temp,sfc.mpg(temp[, names[j] ],mass))
      temp[, names3[j] ] <- with(temp,sfc.kWh(temp[, names[j] ],mass))
    }
    return(temp)
  }

  enCalc.LU <- function(gtfsFile, length) {
    temp <- gtfsFile
    temp$miles <- temp$distGMAPSmet*0.000621371
    temp$stops_mile <- temp$num.stops/temp$miles
    temp$avg_speed <- temp$miles/(temp$timeGMAPSmin/60)
    temp$ai <- with(temp, accel.Map.LU(stops_mile))
    temp$vaero <- with(temp, speed.Map(avg_speed))
    temp$mass <- masses[length]
    temp$bus_type <- bus.labels[length]
    for(j in 1:length(drive.Eff)) {
      temp[, names[j] ] <- with(temp, approx.sfc(c.Aero(mass), vAero, c.Roll, ai, drive.Eff[j], regen.Eff[j]))
      temp[, names2[j] ] <- with(temp,sfc.mpg(temp[, names[j] ],mass))
      temp[, names3[j] ] <- with(temp,sfc.kWh(temp[, names[j] ],mass))
    }
    return(temp)
  }

  #Bus weights - default
  if(is.null(mass.vec)) {
    bus35 <- 27030*0.453592   #convert from lbs to kg
    bus40 <- 30870*0.453592 #convert from lbs to kg
    bus60 <- 49345*0.453592 #convert from lbs to kg
    masses <- c(bus35, bus40, bus60)
    bus.labels <- c("35ft", "40ft", "60ft")
  } else {
    masses <- mass.vec
    bus.labels <- mass.labels
  }
  #efficiencies for BEB and FCEB
  drive.Eff <- c(0.92, 0.62)
  regen.Eff <- c(0.89, 0.58)

  c.Roll <- RRC*g
  fuels <- c("Electric", "Fuelcell")
  agencies <- c("SR","LU")
  names <- c("Electric", "Fuelcell")
  names2 <- c("Electric_mpg", "Fuelcell_mpg")
  names3 <- c("Electric_kWh", "Fuelcell_kWh")

  if(!file.exists(file.path(summary.loc, paste(ag.name, "All Annual Routes.RDS")))) {
    gtfs.length <- gtfs_lengthr(gtfs.obj, location = input.loc, logs = FALSE, quiet = TRUE, ignore.local = FALSE)
    gtfs.frames <- gtfs_framer(gtfs.length)
    gtfs.year <- year_tabler(gtfs.length)
    gtfs.day <- day_tabler(calendar = gtfs.year, trips = gtfs.frames)
    gtfs.summary <- gtfs_summer(time.table = gtfs.day, gtfs.obj = gtfs.length, location = summary.loc)
  } else {
    gtfs.summary <- readRDS(file.path(summary.loc, paste(ag.name, "All Annual Routes.RDS")))
  }
  en.table <- data.frame()
  if(large.Ag) {
    for(i in 1:length(masses)) {
      en.table <- rbind(en.table, enCalc.LU(gtfs.summary, i))
    }
  } else {
    for(i in 1:length(masses)){
      en.table <- rbind(en.table, enCalc.SR(gtfs.summary, i))
    }
  }
  en.table <- en.table %>%
    group_by(bus_type, route_short_name) %>%
    summarise_all(mean, na.rm=TRUE)
  en.table <- select(en.table, bus_type, route_short_name, timeGMAPSmin, miles, dist.GTFS, avg_speed, Electric_kWh, Fuelcell_kWh)
  for(i in 1:nrow(en.table)) {
    if(en.table$dist.GTFS[i] == -Inf) {
      en.table$dist.GTFS[i] <- NA
    }
  }
  if(!dir.exists(output.loc)) {
    dir.create(output.loc, showWarnings = FALSE, recursive = TRUE)
  }
  write.csv(en.table, file = file.path(output.loc, paste(ag.name, "Energy Table.csv")))
  if(surpress.output) {
    return(0)
  } else {
    return(en.table)
  }
}
